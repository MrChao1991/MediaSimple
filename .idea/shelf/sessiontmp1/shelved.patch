Index: fx_lib_camera/src/main/java/com/cfox/camera/camera/session/CameraSession.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.cfox.camera.camera.session;\n\nimport android.content.Context;\nimport android.hardware.camera2.CameraAccessException;\nimport android.hardware.camera2.CameraCaptureSession;\nimport android.hardware.camera2.CameraCharacteristics;\nimport android.hardware.camera2.CameraDevice;\nimport android.hardware.camera2.CameraMetadata;\nimport android.hardware.camera2.CaptureFailure;\nimport android.hardware.camera2.CaptureRequest;\nimport android.hardware.camera2.TotalCaptureResult;\nimport android.util.Log;\n\nimport androidx.annotation.NonNull;\n\nimport com.cfox.camera.FxException;\nimport com.cfox.camera.camera.CameraInfo;\nimport com.cfox.camera.camera.CameraInfoHelper;\nimport com.cfox.camera.camera.device.FxCameraDevice;\nimport com.cfox.camera.camera.device.IFxCameraDevice;\nimport com.cfox.camera.surface.ISurfaceHelper;\nimport com.cfox.camera.utils.FxError;\nimport com.cfox.camera.utils.FxRe;\nimport com.cfox.camera.utils.FxRequest;\nimport com.cfox.camera.utils.FxResult;\nimport com.cfox.camera.utils.ThreadHandlerManager;\n\nimport io.reactivex.Observable;\nimport io.reactivex.ObservableEmitter;\nimport io.reactivex.ObservableOnSubscribe;\nimport io.reactivex.functions.Function;\n\npublic abstract class CameraSession implements ICameraSession {\n    private static final String TAG = \"CameraSession\";\n    CameraCaptureSession mCaptureSession;\n    private boolean mFirstFrameCompleted = false;\n    private IFxCameraDevice mFxCameraDevice;\n    private CameraDevice mCameraDevice;\n    private CameraInfo mCameraInfo;\n\n    CameraSession(Context context) {\n        mFxCameraDevice = FxCameraDevice.getsInstance(context);\n    }\n\n    @Override\n    public Observable<FxResult> onOpenCamera(FxRequest request) {\n        return mFxCameraDevice.openCameraDevice(request).map(new Function<FxResult, FxResult>() {\n            @Override\n            public FxResult apply(FxResult result) throws Exception {\n                mCameraDevice = (CameraDevice) result.getObj(FxRe.Key.CAMERA_DEVICE);\n                mCameraInfo = CameraInfoHelper.getInstance().getCameraInfo(mCameraDevice.getId());\n                return result;\n            }\n        });\n    }\n\n    @Override\n    public CaptureRequest.Builder onCreateCaptureRequest(int templateType) throws CameraAccessException {\n        return mCameraDevice.createCaptureRequest(templateType);\n    }\n\n    public Observable<FxResult> onCreatePreviewSession(FxRequest request) {\n        final ISurfaceHelper surfaceHelper = (ISurfaceHelper) request.getObj(FxRe.Key.SURFACE_HELPER);\n        Log.d(TAG, \"createPreviewSession: ---->\" + surfaceHelper.getSurfaces().size());\n        closeSession();\n        return Observable.create(new ObservableOnSubscribe<FxResult>() {\n            @Override\n            public void subscribe(final ObservableEmitter<FxResult> emitter) throws Exception {\n                mCameraDevice.createCaptureSession(surfaceHelper.getSurfaces(), new CameraCaptureSession.StateCallback() {\n                    @Override\n                    public void onConfigured(@NonNull CameraCaptureSession session) {\n                        Log.d(TAG, \"onConfigured: create session success .....\");\n                        mCaptureSession = session;\n                        emitter.onNext(new FxResult());\n                    }\n\n                    @Override\n                    public void onConfigureFailed(@NonNull CameraCaptureSession session) {\n                        emitter.onError(new FxException(\"Create Preview Session failed  \",FxError.ERROR_CODE_CREATE_PREVIEW_SESSION));\n                    }\n                }, ThreadHandlerManager.getInstance().obtain(ThreadHandlerManager.Tag.T_TYPE_CAMERA).getHandler());\n            }\n        });\n    }\n\n    @Override\n    public Observable<FxResult> onPreviewRepeatingRequest(FxRequest request) {\n        mFirstFrameCompleted = false;\n        final CaptureRequest.Builder requestBuilder = (CaptureRequest.Builder) request.getObj(FxRe.Key.REQUEST_BUILDER);\n        return Observable.create(new ObservableOnSubscribe<FxResult>() {\n            @Override\n            public void subscribe(final ObservableEmitter<FxResult> emitter) throws Exception {\n                mCaptureSession.setRepeatingRequest(requestBuilder.build(), new CameraCaptureSession.CaptureCallback() {\n                    @Override\n                    public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) {\n                        super.onCaptureCompleted(session, request, result);\n                        if (!mFirstFrameCompleted) {\n                            mFirstFrameCompleted = true;\n                            emitter.onNext(new FxResult());\n                            Log.d(TAG, \"mFirstFrameCompleted  onCaptureCompleted: .....\");\n                        }\n                    }\n\n                    @Override\n                    public void onCaptureFailed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureFailure failure) {\n                        super.onCaptureFailed(session, request, failure);\n                        Log.d(TAG, \"onCaptureFailed: ....\");\n                    }\n                }, ThreadHandlerManager.getInstance().obtain(ThreadHandlerManager.Tag.T_TYPE_CAMERA).getHandler());\n\n            }\n        });\n    }\n\n    @Override\n    public Observable<FxResult> onClose() {\n        if (mCameraDevice == null) return null;\n        return mFxCameraDevice.closeCameraDevice(/*mCameraDevice.getId()*/).map(new Function<FxResult, FxResult>() {\n            @Override\n            public FxResult apply(FxResult result) throws Exception {\n                closeSession();\n                return result;\n            }\n        });\n    }\n\n    private void closeSession() {\n        Log.d(TAG, \"closeSession: .......\");\n        if (mCaptureSession != null) {\n            mCaptureSession.close();\n            mCaptureSession = null;\n        }\n    }\n\n    @Override\n    public boolean isAutoFocusSupported() {\n        boolean autoFocusSupported = true;\n        int[] afAvailableModes = mCameraInfo.getCharacteristics().get(CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES);\n\n        if (afAvailableModes.length == 0 || (afAvailableModes.length == 1\n                && afAvailableModes[0] == CameraMetadata.CONTROL_AF_MODE_OFF)) {\n            autoFocusSupported = false;\n        }\n        return autoFocusSupported;\n    }\n\n    @Override\n    public boolean isRawSupported() {\n        return false;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- fx_lib_camera/src/main/java/com/cfox/camera/camera/session/CameraSession.java	(revision 5eac4a8b8dc2850ffbbcf1bf6640e9fce3d7ed4e)
+++ fx_lib_camera/src/main/java/com/cfox/camera/camera/session/CameraSession.java	(date 1573469516000)
@@ -134,18 +134,21 @@
 
     @Override
     public boolean isAutoFocusSupported() {
-        boolean autoFocusSupported = true;
-        int[] afAvailableModes = mCameraInfo.getCharacteristics().get(CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES);
-
-        if (afAvailableModes.length == 0 || (afAvailableModes.length == 1
-                && afAvailableModes[0] == CameraMetadata.CONTROL_AF_MODE_OFF)) {
-            autoFocusSupported = false;
-        }
-        return autoFocusSupported;
+        Float minFocusDist = mCameraInfo.getCharacteristics().get(CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE);
+        Log.d(TAG, "isAutoFocusSupported: minFocusDist:" + minFocusDist);
+        return minFocusDist != null && minFocusDist > 0;
     }
 
     @Override
     public boolean isRawSupported() {
-        return false;
+        boolean rawSupported = false;
+        int[] modes = mCameraInfo.getCharacteristics().get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);
+        for (int mode : modes) {
+            if (mode == CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW) {
+                rawSupported = true;
+                break;
+            }
+        }
+        return rawSupported;
     }
 }
